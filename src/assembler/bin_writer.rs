//
// Copyright 2018 The c8s Developers. See the COPYRIGHT
// file at the top-level directory of this distribution.
//
// Licensed under the MIT license <LICENSE-MIT or http://opensource.org/licenses/MIT>.
// All files in the project carrying such notice may not be copied, modified, or 
// distributed except according to those terms.
//

use assembler::data_range;
use assembler::data_range::DataRange;

// MARK: - Public API

/**
 Converts the provided data ranges into a single binary image. These data ranges
 cannot overlap and still yield a valid binary image. It is the responsibility of
 the caller to ensure this does not happen.
 @param ranges The data ranges to convert to binary image format.
 @return The complete binary image (including padding between ranges) of the given data ranges.
 */
pub fn bin_representation_of_data_ranges<'a>(ranges: &'a [DataRange]) -> Vec<u8> {
  assert!(data_range::find_overlapping_ranges(ranges).len() == 0);

  // All records are collected into a list.
  let mut image = Vec::new();

  // Data ranges sorted by their start addresses.
  let sorted_ranges: Vec<&DataRange> = {
    let mut ranges = ranges.iter().collect::<Vec<_>>();
    ranges.sort();
    ranges
  };

  // Consume range references by extending the image to fill.
  for range in sorted_ranges.into_iter() {
    let start_address = usize::from(range.address_range().start);

    // Append zero bytes from the end of the last range to the start of the current.
    let last_end_address = image.len();
    image.extend({
      [ 0u8 ]
        .into_iter()
        .cycle()
        .take(start_address - last_end_address)
    });

    // Add the data from the range.
    image.extend(range.data().iter());
  }

  image
}

// MARK: - Tests

#[cfg(test)]
mod tests {

  use twelve_bit::u12::*;

  use assembler::data_range::DataRange;

  use super::bin_representation_of_data_ranges;

  #[test]
  fn test_bin_representation_of_data_ranges_no_ranges() {
    // An empty set of data ranges yields just an EOF marker.
    assert_eq!(bin_representation_of_data_ranges(&[]), Vec::<u8>::new());
  }

  #[test]
  fn test_bin_representation_of_data_ranges_pads_first_empty() {
    let data_range = DataRange::new(u12![0x01]);
    assert_eq!(bin_representation_of_data_ranges(&[data_range]), vec![0x00]);
  }

  #[test]
  fn test_bin_representation_of_data_ranges_pads_first_full() {
    let mut data_range = DataRange::new(u12![0x03]);
    data_range.append(&vec![0xFF]);
    assert_eq!(bin_representation_of_data_ranges(&[data_range]), vec![0x00, 0x00, 0x00, 0xFF]);
  }

  #[test]
  fn test_bin_representation_of_data_ranges_one_range() {
    // Build an average-case binary image.
    let mut data_range = DataRange::new(u12![0x010]);
    data_range.append(&vec![0x21,0x46,0x01,0x36,0x01,0x21,0x47,0x01,0x36,0x00,0x7E,0xFE,0x09,0xD2,0x19,0x01]);
    data_range.append(&vec![0x21,0x46,0x01,0x7E,0x17,0xC2,0x00,0x01,0xFF,0x5F,0x16,0x00,0x21,0x48,0x01,0x19]);
    data_range.append(&vec![0x19,0x4E,0x79,0x23,0x46,0x23,0x96,0x57,0x78,0x23,0x9E,0xDA,0x3F,0x01,0xB2,0xCA]);
    data_range.append(&vec![0x3F,0x01,0x56,0x70,0x2B,0x5E,0x71,0x2B,0x72,0x2B,0x73,0x21,0x46,0x01,0x34,0x21]);

    // Validate the average case yielded the anticipated result.
    let bin_rep_average = bin_representation_of_data_ranges(&[data_range]);
    let expected_bin_rep_average = vec![
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x21,0x46,0x01,0x36,0x01,0x21,0x47,0x01,0x36,0x00,0x7E,0xFE,0x09,0xD2,0x19,0x01,
      0x21,0x46,0x01,0x7E,0x17,0xC2,0x00,0x01,0xFF,0x5F,0x16,0x00,0x21,0x48,0x01,0x19,
      0x19,0x4E,0x79,0x23,0x46,0x23,0x96,0x57,0x78,0x23,0x9E,0xDA,0x3F,0x01,0xB2,0xCA,
      0x3F,0x01,0x56,0x70,0x2B,0x5E,0x71,0x2B,0x72,0x2B,0x73,0x21,0x46,0x01,0x34,0x21
    ];
    assert_eq!(bin_rep_average, expected_bin_rep_average);
  }

  #[test]
  fn test_ihex_representation_of_data_ranges_adjacent_ranges() {
    // Build a pair of adjacent data ranges.
    let mut range_a = DataRange::new(u12![0x010]);
    range_a.append(&vec![0x21,0x46,0x01,0x36,0x01,0x21,0x47,0x01,0x36,0x00,0x7E,0xFE,0x09,0xD2,0x19,0x01]);
    let mut range_b = DataRange::new(u12![0x020]);
    range_b.append(&vec![0x21,0x46,0x01,0x7E,0x17,0xC2,0x00,0x01,0xFF,0x5F,0x16,0x00,0x21,0x48,0x01,0x19]);

    // Validate the average case yielded the anticipated result.
    let bin_rep_adjacent = bin_representation_of_data_ranges(&[range_a, range_b]);
    let expected_bin_rep_adjacent = vec![
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x21,0x46,0x01,0x36,0x01,0x21,0x47,0x01,0x36,0x00,0x7E,0xFE,0x09,0xD2,0x19,0x01,
      0x21,0x46,0x01,0x7E,0x17,0xC2,0x00,0x01,0xFF,0x5F,0x16,0x00,0x21,0x48,0x01,0x19
    ];
    assert_eq!(bin_rep_adjacent, expected_bin_rep_adjacent);
  }

  #[test]
  fn test_bin_representation_of_data_ranges_disjoint_ranges() {
    // Build an disjoint pair of data ranges.
    let mut range_a = DataRange::new(u12![0x000]);
    range_a.append(&vec![0x21,0x46,0x01,0x36,0x01,0x21,0x47,0x01,0x36,0x00,0x7E,0xFE,0x09,0xD2,0x19,0x01]);
    let mut range_b = DataRange::new(u12![0x030]);
    range_b.append(&vec![0x3F,0x01,0x56,0x70,0x2B,0x5E,0x71,0x2B,0x72,0x2B,0x73,0x21,0x46,0x01,0x34,0x21]);

    // Validate the average case yielded the anticipated result.
    let bin_rep_disjoint = bin_representation_of_data_ranges(&[range_a, range_b]);
    let expected_bin_rep_disjoint = vec![
      0x21,0x46,0x01,0x36,0x01,0x21,0x47,0x01,0x36,0x00,0x7E,0xFE,0x09,0xD2,0x19,0x01,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x3F,0x01,0x56,0x70,0x2B,0x5E,0x71,0x2B,0x72,0x2B,0x73,0x21,0x46,0x01,0x34,0x21
    ];
    assert_eq!(bin_rep_disjoint, expected_bin_rep_disjoint);
  }

  #[test]
  fn test_ihex_representation_of_data_ranges_uneven_ranges() {
    // Build an uneven set of data ranges.
    let mut range_a = DataRange::new(u12![0x000]);
    range_a.append(&vec![0x21,0x46,0x01,0x36,0x01,0x21,0x47,0x01,0x36,0x00,0x7E,0xFE,0x09,0xD2,0x19]);
    let mut range_b = DataRange::new(u12![0x030]);
    range_b.append(&vec![0x3F,0x01,0x56,0x70,0x2B,0x5E,0x71,0x2B,0x72,0x2B,0x73,0x21,0x46,0x01,0x34,0x21,0x22]);
    let mut range_c = DataRange::new(u12![0x050]);
    range_c.append(&vec![0x3F]);

    // Validate the average case yielded the anticipated result.
    let bin_rep = bin_representation_of_data_ranges(&[range_a, range_b, range_c]);
    let expected_bin_rep = vec![
      0x21,0x46,0x01,0x36,0x01,0x21,0x47,0x01,0x36,0x00,0x7E,0xFE,0x09,0xD2,0x19,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x3F,0x01,0x56,0x70,0x2B,0x5E,0x71,0x2B,0x72,0x2B,0x73,0x21,0x46,0x01,0x34,0x21,
      0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
      0x3F
    ];
    assert_eq!(bin_rep, expected_bin_rep);
  }

  #[test]
  #[should_panic]
  fn test_ihex_representation_of_data_ranges_panics_when_overlapping() {
    // Build an overlapping pair of ranges.
    let mut range_a = DataRange::new(u12![0x100]);
    range_a.append(&vec![0x21,0x46,0x01,0x36,0x01,0x21,0x47,0x01,0x36,0x00,0x7E,0xFE,0x09,0xD2,0x19,0x01]);
    let mut range_b = DataRange::new(u12![0x101]);
    range_b.append(&vec![0x3F,0x01,0x56,0x70,0x2B,0x5E,0x71,0x2B,0x72,0x2B,0x73,0x21,0x46,0x01,0x34,0x21]);
    bin_representation_of_data_ranges(&[range_a, range_b]);
  }

}
